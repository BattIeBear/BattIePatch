using HarmonyLib;
using RimWorld;
using System.Linq;
using System.Reflection;
using Verse;

namespace BattIePatch_ExtremeHemogenExtraction
{
    [HarmonyPatch]
    public static class ITab_Pawn_Visitor_DoPrisonerTab_Patch
    {
        static MethodBase TargetMethod()
        {
            // Get all non-public nested types (classes defined inside ITab_Pawn_Visitor, usually compiler-generated for closures/lambdas)
            var closureType = typeof(ITab_Pawn_Visitor)
                .GetNestedTypes(BindingFlags.NonPublic)
                // Find the nested type whose name contains "DisplayClass8_0"
                // - The C# compiler generates a class named something like "<>c__DisplayClass8_0" when a method (here, DoPrisonerTab) contains a lambda or local function.
                // - "8" in "DisplayClass8_0" is not always the line number; it often relates to the method's metadata token or order of appearance.
                // - To get the metadata token for a type or method in C#, use the MetadataToken property, e.g.:
                //     int token = typeof(ITab_Pawn_Visitor).MetadataToken;
                //     int methodToken = typeof(ITab_Pawn_Visitor).GetMethod("DoPrisonerTab", ...).MetadataToken;
                .FirstOrDefault(t => t.Name.Contains("DisplayClass8_0"));

            // From the closure type, get the method named "<DoPrisonerTab>b__3"
            // - The compiler generates methods for lambdas or local functions inside DoPrisonerTab, naming them like "<DoPrisonerTab>b__3"
            // - "<DoPrisonerTab>b__3" means: this is the 4th (0-based index) lambda or local function inside DoPrisonerTab.
            // - This is the actual method Harmony will patch.
            return closureType?.GetMethod("<DoPrisonerTab>b__3", BindingFlags.Instance | BindingFlags.NonPublic);
        }

        static bool Prefix(object __instance, PrisonerInteractionModeDef m, ref bool __result)
        {
            if (m != PrisonerInteractionModeDefOf.battiepatch_ExtremeHemogenFarm)
            {
                return true;
            }

            // Use Harmony's Traverse API to access fields/properties via reflection in a more readable and chainable way.
            // Traverse is a utility provided by Harmony to simplify reflection operations.
            // - Traverse.Create(obj) wraps the object for further reflection-based access.
            // - .Field("fieldName") specifies the field to access (even if it's private or compiler-generated).
            // - .GetValue() retrieves the value of the specified field.
            //
            // In this case, __instance is the closure object (compiler-generated class for the lambda/local function).
            // The closure contains a field named "<>4__this", which is a reference to the outer ITab_Pawn_Visitor instance.
            // The field name "<>4__this" is generated by the C# compiler for closures to allow the lambda to access members of the outer class.
            // To get this field value without Traverse, you would use reflection like:
            //     var tabField = __instance.GetType().GetField("<>4__this", BindingFlags.Instance | BindingFlags.NonPublic);
            //     var tab = tabField.GetValue(__instance);
            // Traverse simplifies this to a single line:
            var tab = Traverse.Create(__instance).Field("<>4__this").GetValue();
            if (tab == null)
            {
                Log.Error("Could not extract ITab_Pawn_Visitor from closure instance.");
                return true;
            }

            // Similarly, Traverse can be used to access properties (even protected/private) on the ITab_Pawn_Visitor instance.
            // .Property("SelPawn") specifies the property to access.
            // .GetValue() retrieves the value of the property.
            // This is equivalent to using reflection:
            //     var selPawnProp = tab.GetType().GetProperty("SelPawn", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            //     var pawn = selPawnProp.GetValue(tab) as Pawn;
            var pawn = Traverse.Create(tab).Property("SelPawn").GetValue() as Pawn;
            if (pawn == null)
            {
                Log.Error("Could not extract Pawn from ITab_Pawn_Visitor.");
                return true;
            }

            __result = CustomCanUsePrisonerInteractionMode(pawn, m);
            return false;
        }

        public static bool CustomCanUsePrisonerInteractionMode(Pawn pawn, PrisonerInteractionModeDef mode)
        {
            if (ModsConfig.IdeologyActive)
            {
                if (BattIePatchExtremeHemogenExtractionSettings.RequiresBloodfeedingMeme)
                {
                    if (Faction.OfPlayer.ideos.PrimaryIdeo != null)
                    {
                        if (!Faction.OfPlayer.ideos.PrimaryIdeo.memes.Any(meme => meme.defName == "Bloodfeeding"))
                        {
                            pawn.guest.ToggleNonExclusiveInteraction(PrisonerInteractionModeDefOf.battiepatch_ExtremeHemogenFarm, false);
                            return false;
                        }
                    }
                }
            }

            if (mode.hideOnHemogenicPawns && ModsConfig.BiotechActive && pawn.genes != null && pawn.genes.HasActiveGene(GeneDefOf.Hemogenic))
            {
                pawn.guest.ToggleNonExclusiveInteraction(PrisonerInteractionModeDefOf.battiepatch_ExtremeHemogenFarm, false);
                return false;
            }

            return true;
        }
    }
}